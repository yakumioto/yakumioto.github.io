<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go HTTP Response 写超时导致的 EOF 错误 | Mioto&#39;s Blog</title>
<meta name="keywords" content="Go" />
<meta name="description" content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &quot;http://127.0.0.1:8800&quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No.">
<meta name="author" content="">
<link rel="canonical" href="https://mioto.me/post/http-response-write-timeout/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mioto.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mioto.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mioto.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mioto.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://mioto.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.109.0">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Go HTTP Response 写超时导致的 EOF 错误" />
<meta property="og:description" content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &quot;http://127.0.0.1:8800&quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mioto.me/post/http-response-write-timeout/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-01T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-10-01T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go HTTP Response 写超时导致的 EOF 错误"/>
<meta name="twitter:description" content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &quot;http://127.0.0.1:8800&quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://mioto.me/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Go HTTP Response 写超时导致的 EOF 错误",
      "item": "https://mioto.me/post/http-response-write-timeout/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go HTTP Response 写超时导致的 EOF 错误",
  "name": "Go HTTP Response 写超时导致的 EOF 错误",
  "description": "前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get \u0026quot;http://127.0.0.1:8800\u0026quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行\n由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决\n原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了\n但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error\n抓包 源码: https://github.com/yakumioto/demo-response-write-timeout\n由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:\n客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 \u0026#34;No.",
  "keywords": [
    "Go"
  ],
  "articleBody": "前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get \"http://127.0.0.1:8800\": EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行\n由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决\n原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了\n但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error\n抓包 源码: https://github.com/yakumioto/demo-response-write-timeout\n由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:\n客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 \"No.\",\"Time\",\"Source\",\"Destination\",\"Protocol\",\"Length\",\"Info\" \"85\",\"3.662590\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"68\",\"55585 \u003e 8800 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=0 SACK_PERM=1\" \"86\",\"3.662666\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"68\",\"8800 \u003e 55585 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=465914251 SACK_PERM=1\" \"87\",\"3.662675\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251\" \"88\",\"3.662681\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Window Update] 8800 \u003e 55585 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251\" \"89\",\"3.662802\",\"127.0.0.1\",\"127.0.0.1\",\"HTTP\",\"151\",\"GET / HTTP/1.1 \" \"90\",\"3.662813\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465914251 TSecr=465914251\" \"160\",\"18.792318\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"161\",\"18.792325\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"162\",\"18.792359\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465929251 TSecr=465914251\" \"163\",\"18.792363\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#1] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465929251 TSecr=465914251\" \"283\",\"33.925723\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"284\",\"33.925731\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"285\",\"33.925741\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465944251 TSecr=465929251\" \"286\",\"33.925749\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#2] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465944251 TSecr=465929251\" \"345\",\"49.031897\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"346\",\"49.031903\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"347\",\"49.031929\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465959251 TSecr=465944251\" \"348\",\"49.031932\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#3] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465959251 TSecr=465944251\" \"469\",\"63.667058\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [FIN, ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465973767 TSecr=465959251\" \"470\",\"63.667081\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767\" \"471\",\"63.667119\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [FIN, ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767\" \"472\",\"63.667147\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [ACK] Seq=2 Ack=97 Win=408192 Len=0 TSval=465973767 TSecr=465973767\" 源码解析 既然是源码分析那就从头跟起!!!\n入口方法, 为了方便定位追踪源码 // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2854 // 入口函数, 没啥好解释的 func (srv *Server) ListenAndServe() error { ... return srv.Serve(ln) } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2907 // 死循环, 监听请求, 并开一个协程处理 func (srv *Server) Serve(l net.Listener) error { ... for { ... c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(connCtx) } } 这里有一些重要的变量需要记录以下, 后续的源码中会涉及到 b.bufr: conn 的读 buffer b.bufw: conn 的写 buffer, 大小为 4096 byte c.readRequest(ctx): 处理了 req 请求, 同时返回了一个 *response ServeHTTP(w, w.req): 最终 w 会一路下传, 到我们自己所写的处理函数中\n接下来就看这个 w 是如何产生的\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:1794 func (c *conn) serve(ctx context.Context) { ... // HTTP/1.x from here on. ctx, cancelCtx := context.WithCancel(ctx) c.cancelCtx = cancelCtx defer cancelCtx() c.r = \u0026connReader{conn: c} c.bufr = newBufioReader(c.r) c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4\u003c\u003c10) for { w, err := c.readRequest(ctx) ... serverHandler{c.server}.ServeHTTP(w, w.req) ... } } w.w: 可见 w.w 是 w.cw 的 bufio.Writer 相当于调用 w.w.Write(p []byte) == w.cw.Write(p []byte) w.cw: 可见其类型是 chunkWriter 所以如果调用到 w.w.Write(p []byte) == chunkWriter.Write([]byte)\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:418 type response struct { ... w *bufio.Writer // buffers output in chunks to chunkWriter cw chunkWriter ... } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:955 func (c *conn) readRequest(ctx context.Context) (w *response, err error) { ... w = \u0026response{ conn: c, cancelCtx: cancelCtx, req: req, reqBody: req.Body, handlerHeader: make(Header), contentLength: -1, closeNotifyCh: make(chan bool, 1), // We populate these ahead of time so we're not // reading from req.Header after their Handler starts // and maybe mutates it (Issue 14940) wants10KeepAlive: req.wantsHttp10KeepAlive(), wantsClose: req.wantsClose(), } if isH2Upgrade { w.closeAfterReply = true } w.cw.res = w w.w = newBufioWriterSize(\u0026w.cw, bufferBeforeChunkingSize) ... } cw.res.conn: 根据上面的代码发现 conn == w.conn == srv.newConn(rw) cw.res.conn.bufw: 就是 c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4«10), 由此可见 conn write 的缓冲区就是 4096 byte\nfunc (cw *chunkWriter) Write(p []byte) (n int, err error) { ... n, err = cw.res.conn.bufw.Write(p) if cw.chunking \u0026\u0026 err == nil { _, err = cw.res.conn.bufw.Write(crlf) } if err != nil { cw.res.conn.rwc.Close() } return } bufio: 如果数据长度没有超过 len(b.buf) 数据会 copy 到 b.buf 中, 并不会真正写入 b.wr 中\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/bufio/bufio.go:558 type Writer struct { err error buf []byte n int wr io.Writer } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:368 func (b *Writer) Write(p []byte) (nn int, err error) { for len(p) \u003e b.Available() \u0026\u0026 b.err == nil { var n int if b.Buffered() == 0 { // Large write, empty buffer. // Write directly from p to avoid copy. n, b.err = b.wr.Write(p) } else { n = copy(b.buf[b.n:], p) b.n += n b.Flush() } nn += n p = p[n:] } if b.err != nil { return nn, b.err } n := copy(b.buf[b.n:], p) b.n += n nn += n return nn, nil } 参考 https://github.com/golang/go/issues/21389 ",
  "wordCount" : "745",
  "inLanguage": "en",
  "datePublished": "2020-10-01T00:00:00Z",
  "dateModified": "2020-10-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mioto.me/post/http-response-write-timeout/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mioto's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mioto.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mioto.me" accesskey="h" title="Mioto&#39;s Blog (Alt + H)">Mioto&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Go HTTP Response 写超时导致的 EOF 错误
    </h1>
    <div class="post-meta"><span title='2020-10-01 00:00:00 +0000 UTC'>October 1, 2020</span>

</div>
  </header> 
  <div class="post-content"><p>前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 <code>Get &quot;http://127.0.0.1:8800&quot;: EOF</code>, 但是服务端却没有任何 <strong>异常</strong> 所有的日志都是正常执行</p>
<p>由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决</p>
<h2 id="原因">原因<a hidden class="anchor" aria-hidden="true" href="#原因">#</a></h2>
<p>server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了</p>
<p>但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error</p>
<h2 id="抓包">抓包<a hidden class="anchor" aria-hidden="true" href="#抓包">#</a></h2>
<p>源码: <a href="https://github.com/yakumioto/demo-response-write-timeout">https://github.com/yakumioto/demo-response-write-timeout</a></p>
<p>由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:</p>
<ol>
<li>客户端通过三次握手和服务端建立了 TCP 连接</li>
<li>客户端正常的发送了 HTTP Request 请求</li>
<li>正常的保持了一段时间的 Keep-Alive</li>
<li>服务端通过四次挥手和客户端断开了连接</li>
</ol>
<pre tabindex="0"><code class="language-svc" data-lang="svc">&#34;No.&#34;,&#34;Time&#34;,&#34;Source&#34;,&#34;Destination&#34;,&#34;Protocol&#34;,&#34;Length&#34;,&#34;Info&#34;
&#34;85&#34;,&#34;3.662590&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;68&#34;,&#34;55585  &gt;  8800 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=0 SACK_PERM=1&#34;
&#34;86&#34;,&#34;3.662666&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;68&#34;,&#34;8800  &gt;  55585 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=465914251 SACK_PERM=1&#34;
&#34;87&#34;,&#34;3.662675&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;88&#34;,&#34;3.662681&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Window Update] 8800  &gt;  55585 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;89&#34;,&#34;3.662802&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;HTTP&#34;,&#34;151&#34;,&#34;GET / HTTP/1.1 &#34;
&#34;90&#34;,&#34;3.662813&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;160&#34;,&#34;18.792318&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;161&#34;,&#34;18.792325&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;162&#34;,&#34;18.792359&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465929251 TSecr=465914251&#34;
&#34;163&#34;,&#34;18.792363&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#1] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465929251 TSecr=465914251&#34;
&#34;283&#34;,&#34;33.925723&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;284&#34;,&#34;33.925731&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;285&#34;,&#34;33.925741&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465944251 TSecr=465929251&#34;
&#34;286&#34;,&#34;33.925749&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#2] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465944251 TSecr=465929251&#34;
&#34;345&#34;,&#34;49.031897&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;346&#34;,&#34;49.031903&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;347&#34;,&#34;49.031929&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465959251 TSecr=465944251&#34;
&#34;348&#34;,&#34;49.031932&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#3] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465959251 TSecr=465944251&#34;
&#34;469&#34;,&#34;63.667058&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [FIN, ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465973767 TSecr=465959251&#34;
&#34;470&#34;,&#34;63.667081&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767&#34;
&#34;471&#34;,&#34;63.667119&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [FIN, ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767&#34;
&#34;472&#34;,&#34;63.667147&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [ACK] Seq=2 Ack=97 Win=408192 Len=0 TSval=465973767 TSecr=465973767&#34;
</code></pre><h2 id="源码解析">源码解析<a hidden class="anchor" aria-hidden="true" href="#源码解析">#</a></h2>
<p>既然是源码分析那就从头跟起!!!</p>
<h3 id="入口方法-为了方便定位追踪源码">入口方法, 为了方便定位追踪源码<a hidden class="anchor" aria-hidden="true" href="#入口方法-为了方便定位追踪源码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2854
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 入口函数, 没啥好解释的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">srv</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Server</span>) <span style="color:#a6e22e">ListenAndServe</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">srv</span>.<span style="color:#a6e22e">Serve</span>(<span style="color:#a6e22e">ln</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2907
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 死循环, 监听请求, 并开一个协程处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">srv</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Server</span>) <span style="color:#a6e22e">Serve</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listener</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">srv</span>.<span style="color:#a6e22e">newConn</span>(<span style="color:#a6e22e">rw</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">setState</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">rwc</span>, <span style="color:#a6e22e">StateNew</span>) <span style="color:#75715e">// before Serve can return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">serve</span>(<span style="color:#a6e22e">connCtx</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="这里有一些重要的变量需要记录以下-后续的源码中会涉及到">这里有一些重要的变量需要记录以下, 后续的源码中会涉及到<a hidden class="anchor" aria-hidden="true" href="#这里有一些重要的变量需要记录以下-后续的源码中会涉及到">#</a></h3>
<p><code>b.bufr</code>: conn 的读 buffer
<code>b.bufw</code>: conn 的写 buffer, 大小为 4096 byte
<code>c.readRequest(ctx)</code>: 处理了 req 请求, 同时返回了一个 <code>*response</code>
<code>ServeHTTP(w, w.req)</code>: 最终 w 会一路下传, 到我们自己所写的处理函数中</p>
<p>接下来就看这个 <code>w</code> 是如何产生的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:1794
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">conn</span>) <span style="color:#a6e22e">serve</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// HTTP/1.x from here on.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancelCtx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">cancelCtx</span> = <span style="color:#a6e22e">cancelCtx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancelCtx</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">r</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">connReader</span>{<span style="color:#a6e22e">conn</span>: <span style="color:#a6e22e">c</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">bufr</span> = <span style="color:#a6e22e">newBufioReader</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">bufw</span> = <span style="color:#a6e22e">newBufioWriterSize</span>(<span style="color:#a6e22e">checkConnErrorWriter</span>{<span style="color:#a6e22e">c</span>}, <span style="color:#ae81ff">4</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">readRequest</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">serverHandler</span>{<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">server</span>}.<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>w.w</code>: 可见 w.w 是 w.cw 的 bufio.Writer 相当于调用 w.w.Write(p []byte) == w.cw.Write(p []byte)
<code>w.cw</code>: 可见其类型是 chunkWriter 所以如果调用到 w.w.Write(p []byte) == chunkWriter.Write([]byte)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:418
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">response</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">Writer</span> <span style="color:#75715e">// buffers output in chunks to chunkWriter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cw</span> <span style="color:#a6e22e">chunkWriter</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:955
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">conn</span>) <span style="color:#a6e22e">readRequest</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">response</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">response</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">conn</span>:          <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cancelCtx</span>:     <span style="color:#a6e22e">cancelCtx</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">req</span>:           <span style="color:#a6e22e">req</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">reqBody</span>:       <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Body</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">handlerHeader</span>: make(<span style="color:#a6e22e">Header</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">contentLength</span>: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">closeNotifyCh</span>: make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>, <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// We populate these ahead of time so we&#39;re not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// reading from req.Header after their Handler starts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// and maybe mutates it (Issue 14940)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">wants10KeepAlive</span>: <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">wantsHttp10KeepAlive</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wantsClose</span>:       <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">wantsClose</span>(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isH2Upgrade</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">closeAfterReply</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">cw</span>.<span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">w</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">w</span> = <span style="color:#a6e22e">newBufioWriterSize</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">cw</span>, <span style="color:#a6e22e">bufferBeforeChunkingSize</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>cw.res.conn</code>: 根据上面的代码发现 conn == w.conn == srv.newConn(rw)
<code>cw.res.conn.bufw</code>: 就是 c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&laquo;10), 由此可见 conn write 的缓冲区就是 4096 byte</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">chunkWriter</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">cw</span>.<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">bufw</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cw</span>.<span style="color:#a6e22e">chunking</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">cw</span>.<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">bufw</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">crlf</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cw</span>.<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">rwc</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>bufio</code>: 如果数据长度没有超过 len(b.buf) 数据会 copy 到 b.buf 中, 并不会真正写入 b.wr 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/bufio/bufio.go:558
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wr</span>  <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:368
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Writer</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">nn</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">p</span>) &gt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Available</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Buffered</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Large write, empty buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// Write directly from p to avoid copy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">wr</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">n</span> = copy(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">n</span>:], <span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Flush</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">nn</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">n</span>:]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nn</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> copy(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">n</span>:], <span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nn</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nn</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ol>
<li><a href="https://github.com/golang/go/issues/21389">https://github.com/golang/go/issues/21389</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mioto.me/tags/go/">Go</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mioto.me">Mioto&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
