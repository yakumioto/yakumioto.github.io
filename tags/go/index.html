<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go | 一只麻酱</title><meta name=keywords content><meta name=description content="我们都期待自己的存在是特殊的，到头来却平凡不已。"><meta name=author content="Mioto Yaku"><link rel=canonical href=https://mioto.me/tags/go/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><link rel=icon href=https://mioto.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mioto.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mioto.me/favicon-32x32.png><link rel=apple-touch-icon href=https://mioto.me/apple-touch-icon.png><link rel=mask-icon href=https://mioto.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://mioto.me/tags/go/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-102233768-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Go"><meta property="og:description" content="我们都期待自己的存在是特殊的，到头来却平凡不已。"><meta property="og:type" content="website"><meta property="og:url" content="https://mioto.me/tags/go/"><meta property="og:site_name" content="一只麻酱"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go"><meta name=twitter:description content="我们都期待自己的存在是特殊的，到头来却平凡不已。"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mioto.me accesskey=h title="一只麻酱 (Alt + H)">一只麻酱</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mioto.me/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mioto.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Go</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>使用 Go 语言每秒百万量级的模拟数据生成优化总结</h2></header><div class=entry-content><p>本文旨在深入研究如何使用Go语言优化模拟数据生成性能。我们将介绍三个不同版本的代码实现，并详细分析它们的性能和优点。
版本一：基础实现 首先，让我们来看看第一个版本的代码，这是一个基础实现，没有引入并发。以下是版本一的核心代码：
func randomVersion1(labels []int) *strings.Builder { str := &strings.Builder{} for i := 0; i &lt; len(labels); i++ { switch labels[i] { case 0: str.WriteString(strconv.Itoa(rand.Intn(2) - 1)) case 1: str.WriteString(fmt.Sprintf("%.8f", 0.1+rand.Float64()*(1-0.1))) } if i &lt; len(labels)-1 { str.WriteString(",") } } return str } func TestVersion1(t *testing.T) { f, _ := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644) buf := bufio.NewWriter(f) s := time.Now() buf.WriteString(fmt.Sprintf("%s\n", header)) for i := 0; i &lt; 1000000; i++ { buf....</p></div><footer class=entry-footer><span title='2021-09-25 10:30:23 +0800 +0800'>九月 25, 2021</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to 使用 Go 语言每秒百万量级的模拟数据生成优化总结" href=https://mioto.me/posts/use-go-to-generate-millions-of-mock-data-generation-per-second/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Plan9 汇编入门讲解</h2></header><div class=entry-content><p>为什么要看 Plan9 汇编？如果你是 Go 开发者，去学习和理解一下 Plan9 是很有必要的，因为它可以解决你对一段代码的理解（为什么这样不行？那样却可以？）。
Plan9 不同于 AT&T 和 Intel 汇编器，但是懂这两个汇编语法的话对理解 Plan9 还是有很大帮助的。
疑惑 // 为什么这个函数的返回值会是 -1 func demo1() int { ret := -1 defer func() { ret = 1 }() return ret } // output: -1 // 为什么这个函数的返回值会是 1 func demo2() (ret int) { defer func() { ret = 1 }() return ret } // output: 1 相信大部分人都看过类似的解答，demo1 中是临时变量导致的，而 demo2 中没有临时变量，这是最终结果。
在汇编层面到底做了什么？本文将会探讨这个问题。（本文所使用的平台是 MacOS AMD64）不同的平台指令集和寄存器都不一样。
基础 通用寄存器 下面是通用通用寄存器的名字在 IA64 和 plan9 中的对应关系：...</p></div><footer class=entry-footer><span title='2021-01-19 17:23:23 +0800 +0800'>一月 19, 2021</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Plan9 汇编入门讲解" href=https://mioto.me/posts/plan9-assembly/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go HTTP Response 写超时导致的 EOF 错误</h2></header><div class=entry-content><p>前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get "http://127.0.0.1:8800": EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 "No....</p></div><footer class=entry-footer><span title='2020-10-01 00:00:00 +0000 UTC'>十月 1, 2020</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Go HTTP Response 写超时导致的 EOF 错误" href=https://mioto.me/posts/http-response-write-timeout/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Hyperledger Fabric 加入通道时遇到 channel doesn't exist 问题</h2></header><div class=entry-content><p>据同事说 node sdk@v2.x.x 版本中没有对网络操作相关的 API 实现, 所以只能自己照着 v1.4.x 版本的 手撸底层代码, 但是在实现 JoinChain 这个功能时出现了 channel doesn't exist 错误
原因 // SignedProposal 部分结构 { "proposal_bytes": { "header": { "channel_header": { "channel_id": "" }, "signature_header": { "creator": { "mspid": "", "id_bytes": "" } } }, "payload": "" }, "signature": "" } 当 peer 收到 client 发来的 SignedProposal 时, 会进行签名校验
根据 proposal_bytes.header.channel_header.channel_id 获取对应的 mspMgmtMgr, 如果此时通道不存在, 则会创建一个未经初始化的 mspMgmtMgr 根据 proposal_bytes.header.signature_header.creator.mspid 获取对应的 mspManagerImpl, 但是由于 mspMgmtMgr 未初始化, 所以直接返回了 channel doesn't exist 源码追踪 重要的事情说三遍...</p></div><footer class=entry-footer><span title='2020-06-27 00:00:00 +0000 UTC'>六月 27, 2020</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Hyperledger Fabric 加入通道时遇到 channel doesn't exist 问题" href=https://mioto.me/posts/fab-join-channel-issue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Hyperledger Fabric peer block 的交付流程详解</h2></header><div class=entry-content><p>本文基于 hyperldeger fabric 1.4.7 进行代码追踪讲解
假设场景描述:
peer 重启场景 peer 有 user channel peer 使用的是 goleveldb peer 的 core.peer.gossip.orgLeader 为 true 流程简介 初始化账本根据账本中保存的 channel id 创建通道实例, 并初始化与之对等的 gossip 服务, 用 来接收对应通道的最新的 配置或交易 block, 接收到 block 后, 经过 Verify, Validate, Validate RW sets 三个验证步骤, 提交给 Ledger Commiter 进行写入文件, 并将当前通道的 blkMgrInfo 更新到最新状态
源码追踪 伊始: main -> node.Cmd -> startCmd -> nodeStartCmd -> serve
peer.Initialize 文件: core/peer/peer.go:241
初始化 ledgermgmt, 里面做的事情太多了, 要讲清楚有点困难建议大家自己去看看, 里面主要做的就是 各种初始化工作
// /var/hyperledger/production/ledgersData 下有这些东西, 这里面的工作跟此目录有关 // chains/index goleveldb: 保存了所有通道的最新状态信息 // fileLock goleveldb: 用于锁程序的,文章最末尾有介绍 // historyLeveldb goleveldb: 保存历史交易的 // ledgerProvider goleveldb: 保存的是 chain ids, 也就是通道id // pvtdataStore goleveldb: 存储私有数据库 // stateLeveldb goleveldb: 世界状态数据库, 可以替换为 couchdb // 这两个我不确定没有细追 // configHistory 看名字应该是保存了 config block 相关的东西....</p></div><footer class=entry-footer><span title='2020-06-15 00:00:00 +0000 UTC'>六月 15, 2020</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Hyperledger Fabric peer block 的交付流程详解" href=https://mioto.me/posts/fab-peer-deliver-block/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go 删除 Slice 中的某一个值</h2></header><div class=entry-content><p>方法一 优点: 速度最快 缺点: 会导致切片数据顺序改变
a := []string{"A", "B", "C", "D", "E"} i := 2 a[i] = a[len(a)-1] // 将数组的最后一位赋值给需要删除的 index 上 a = a[:len(a)-1] // 移除掉最后一个没用的数据 // Output: // [A B E D] 方法二 优点: 速度会随着切片长度改变 缺点: 保持原有切片顺序
a := []string{"A", "B", "C", "D", "E"} i := 2 a = append(a[:i], a[i+1:]...) // Output: // [A B D E] Benchmark goos: linux goarch: amd64 pkg: github.com/yakumioto/go-example/benchmark/delete-element-slice Benchmark1 Benchmark1-4 1000000000 0....</p></div><footer class=entry-footer><span title='2020-06-03 00:00:00 +0000 UTC'>六月 3, 2020</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Go 删除 Slice 中的某一个值" href=https://mioto.me/posts/delete-element-slice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Fabric 中 etcdraft 共识讲解</h2></header><div class=entry-content><p>为什么要通过 etcdraft 来进行共识?
我觉得有以下原因
solo 并不适合大多数场景, 例如: 组织A, 组织B, 都想在自己放置共识节点 kafka 虽然能满足以上需求, 但是 kafka 加上 zookeeper 需要额外部署并且实在是太重了, 不方便部署 所以基于 etcdraft 的共识来了, 解决了以上的痛点
重要的话说三遍!
千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!!
核心接口 以下是我认为实现 etcdraft 共识核心的接口
// ClusterServer 集群Server接口 type ClusterServer interface { Step(Cluster_StepServer) error } // ClusterClient 集群Client接口 type ClusterClient interface { Step(ctx context.Context, opts ...grpc.CallOption) (orderer.Cluster_StepClient, error) } // Handler 用于共识的两个接口 type Handler interface { OnConsensus(channel string, sender uint64, req *orderer.ConsensusRequest) error OnSubmit(channel string, sender uint64, req *orderer....</p></div><footer class=entry-footer><span title='2020-01-15 00:00:00 +0000 UTC'>一月 15, 2020</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Fabric 中 etcdraft 共识讲解" href=https://mioto.me/posts/etcdraft-exploration-in-fabric-orderer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go 100 行实现 HTTP(S) 正向代理</h2></header><div class=entry-content><p>目标是现实一个 HTTP HTTPS 的代理服务器, 目前代理的实现方法有两种
普通代理: 这种代理扮演的是中间人角色, 对于客户端来说, 它就服务器, 对于服务端来说, 它是客户端, 它负责在中间来回传递 HTTP 报文
隧道代理: 它是通过 HTTP 正文部分(body) 完成代理, 以 HTTP 的方式实现基于 TCP 的应用层协议代理, 这种代理使用 HTTP 的 CONNECT 方法建立连接
这是一次 HTTP 的请求, 用 \r\n 进行换行, 碰到连续两个 \r\n 后内容为请求数据, 分为以下几个部分
请求行 (request line) 请求头 (header) 空行 请求数据 (body) curl -Lv http://baidu.com > GET / HTTP/1.1 > Host: baidu.com > User-Agent: curl/7.68.0 > Accept: */* > * Mark bundle as not supporting multiuse &lt; HTTP/1....</p></div><footer class=entry-footer><span title='2019-08-21 00:00:00 +0000 UTC'>八月 21, 2019</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Go 100 行实现 HTTP(S) 正向代理" href=https://mioto.me/posts/http-s-proxy-in-golang-in-less-than-100-lines-of-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go HTTP POST 附件</h2></header><div class=entry-content><p>前段时间为了使用 adb 进行钉钉打卡, 写了个 Go 的程序, 想着万一没打上怎么办, 不如截个图发给自己(现在以 root, 辣鸡钉钉), 文章只为了记录一下实现.
// curl -X POST https://example.com/sendPhoto -F photo=@./screen.png // 以下代码是根据以上 curl 命令的实现 buf := &bytes.Buffer{} mu := multipart.NewWriter(buf) part, err := mu.CreatePart(textproto.MIMEHeader{ "Content-Disposition": []string{`form-data; name="photo"; filename="screen.png"`}, "Content-Type":[]string{"application/octet-stream"}, }) checkError(err) fp, _ := os.Open("/home/mioto/screen.png") io.Copy(part, fp) mu.Close() req, err := http.NewRequest(http.MethodPost, "https://example.com/sendPhoto", bf) checkError(err) req.Header.Set("Content-Type", mu.FormDataContentType()) res, err := http.DefaultClient.Do(req) checkError(err)</p></div><footer class=entry-footer><span title='2019-05-16 00:00:00 +0000 UTC'>五月 16, 2019</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Go HTTP POST 附件" href=https://mioto.me/posts/go-http-post-attachment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go 解析 ECPrivate Key 遇到的问题</h2></header><div class=entry-content><p>最近在做 fabric 证书私钥管理系统, 遇到的一个问题, 在使用 x509.ParseECPrivateKey() 方法的时候会直接报错, 而 fabric 确实用的是 椭圆曲线算法
错误输出: x509: failed to parse EC private key: asn1: structure error: tags don't match (4 vs {class:0 tag:16 length:19 isCompound:true}) {optional:false explicit:false application:false private:false defaultValue:&lt;nil> tag:&lt;nil> stringType:0 timeType:0 set:false omitEmpty:false} @5
原因是 fabric 将私钥转成 pem 格式的时候使用的方法是 x509.MarshalPKCS8PrivateKey()
解决办法 block, _ := pem.Decode(pemBytes) key, err := x509.ParsePKCS8PrivateKey(block.Bytes) checkErr(err) switch priv := key.(type) { case *ecdsa.PrivateKey: // do something }</p></div><footer class=entry-footer><span title='2019-05-07 08:45:00 +0000 UTC'>五月 7, 2019</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Mioto Yaku</footer><a class=entry-link aria-label="post link to Go 解析 ECPrivate Key 遇到的问题" href=https://mioto.me/posts/go-parse-ec-private-key/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://mioto.me/tags/go/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://mioto.me>一只麻酱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>