<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go on 一只麻酱</title><link>https://mioto.me/tags/go/</link><description>Recent content in Go on 一只麻酱</description><generator>Hugo -- 0.125.4</generator><language>zh</language><lastBuildDate>Sat, 25 Sep 2021 10:30:23 +0800</lastBuildDate><atom:link href="https://mioto.me/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Go 语言每秒百万量级的模拟数据生成优化总结</title><link>https://mioto.me/posts/use-go-to-generate-millions-of-mock-data-generation-per-second/</link><pubDate>Sat, 25 Sep 2021 10:30:23 +0800</pubDate><guid>https://mioto.me/posts/use-go-to-generate-millions-of-mock-data-generation-per-second/</guid><description>本文旨在深入研究如何使用Go语言优化模拟数据生成性能。我们将介绍三个不同版本的代码实现，并详细分析它们的性能和优点。
版本一：基础实现 首先，让我们来看看第一个版本的代码，这是一个基础实现，没有引入并发。以下是版本一的核心代码：
func randomVersion1(labels []int) *strings.Builder { str := &amp;amp;strings.Builder{} for i := 0; i &amp;lt; len(labels); i++ { switch labels[i] { case 0: str.WriteString(strconv.Itoa(rand.Intn(2) - 1)) case 1: str.WriteString(fmt.Sprintf(&amp;#34;%.8f&amp;#34;, 0.1+rand.Float64()*(1-0.1))) } if i &amp;lt; len(labels)-1 { str.WriteString(&amp;#34;,&amp;#34;) } } return str } func TestVersion1(t *testing.T) { f, _ := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644) buf := bufio.NewWriter(f) s := time.Now() buf.WriteString(fmt.Sprintf(&amp;#34;%s\n&amp;#34;, header)) for i := 0; i &amp;lt; 1000000; i++ { buf.</description></item><item><title>Plan9 汇编入门讲解</title><link>https://mioto.me/posts/plan9-assembly/</link><pubDate>Tue, 19 Jan 2021 17:23:23 +0800</pubDate><guid>https://mioto.me/posts/plan9-assembly/</guid><description>为什么要看 Plan9 汇编？如果你是 Go 开发者，去学习和理解一下 Plan9 是很有必要的，因为它可以解决你对一段代码的理解（为什么这样不行？那样却可以？）。
Plan9 不同于 AT&amp;amp;T 和 Intel 汇编器，但是懂这两个汇编语法的话对理解 Plan9 还是有很大帮助的。
疑惑 // 为什么这个函数的返回值会是 -1 func demo1() int { ret := -1 defer func() { ret = 1 }() return ret } // output: -1 // 为什么这个函数的返回值会是 1 func demo2() (ret int) { defer func() { ret = 1 }() return ret } // output: 1 相信大部分人都看过类似的解答，demo1 中是临时变量导致的，而 demo2 中没有临时变量，这是最终结果。
在汇编层面到底做了什么？本文将会探讨这个问题。（本文所使用的平台是 MacOS AMD64）不同的平台指令集和寄存器都不一样。
基础 通用寄存器 下面是通用通用寄存器的名字在 IA64 和 plan9 中的对应关系：</description></item><item><title>Go HTTP Response 写超时导致的 EOF 错误</title><link>https://mioto.me/posts/http-response-write-timeout/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/http-response-write-timeout/</guid><description>前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &amp;quot;http://127.0.0.1:8800&amp;quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &amp;#34;No.</description></item><item><title>Hyperledger Fabric 加入通道时遇到 channel doesn't exist 问题</title><link>https://mioto.me/posts/fab-join-channel-issue/</link><pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/fab-join-channel-issue/</guid><description>据同事说 node sdk@v2.x.x 版本中没有对网络操作相关的 API 实现, 所以只能自己照着 v1.4.x 版本的 手撸底层代码, 但是在实现 JoinChain 这个功能时出现了 channel doesn't exist 错误
原因 // SignedProposal 部分结构 { &amp;#34;proposal_bytes&amp;#34;: { &amp;#34;header&amp;#34;: { &amp;#34;channel_header&amp;#34;: { &amp;#34;channel_id&amp;#34;: &amp;#34;&amp;#34; }, &amp;#34;signature_header&amp;#34;: { &amp;#34;creator&amp;#34;: { &amp;#34;mspid&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;id_bytes&amp;#34;: &amp;#34;&amp;#34; } } }, &amp;#34;payload&amp;#34;: &amp;#34;&amp;#34; }, &amp;#34;signature&amp;#34;: &amp;#34;&amp;#34; } 当 peer 收到 client 发来的 SignedProposal 时, 会进行签名校验
根据 proposal_bytes.header.channel_header.channel_id 获取对应的 mspMgmtMgr, 如果此时通道不存在, 则会创建一个未经初始化的 mspMgmtMgr 根据 proposal_bytes.header.signature_header.creator.mspid 获取对应的 mspManagerImpl, 但是由于 mspMgmtMgr 未初始化, 所以直接返回了 channel doesn't exist 源码追踪 重要的事情说三遍</description></item><item><title>Hyperledger Fabric peer block 的交付流程详解</title><link>https://mioto.me/posts/fab-peer-deliver-block/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/fab-peer-deliver-block/</guid><description>本文基于 hyperldeger fabric 1.4.7 进行代码追踪讲解
假设场景描述:
peer 重启场景 peer 有 user channel peer 使用的是 goleveldb peer 的 core.peer.gossip.orgLeader 为 true 流程简介 初始化账本根据账本中保存的 channel id 创建通道实例, 并初始化与之对等的 gossip 服务, 用 来接收对应通道的最新的 配置或交易 block, 接收到 block 后, 经过 Verify, Validate, Validate RW sets 三个验证步骤, 提交给 Ledger Commiter 进行写入文件, 并将当前通道的 blkMgrInfo 更新到最新状态
源码追踪 伊始: main -&amp;gt; node.Cmd -&amp;gt; startCmd -&amp;gt; nodeStartCmd -&amp;gt; serve
peer.Initialize 文件: core/peer/peer.go:241
初始化 ledgermgmt, 里面做的事情太多了, 要讲清楚有点困难建议大家自己去看看, 里面主要做的就是 各种初始化工作
// /var/hyperledger/production/ledgersData 下有这些东西, 这里面的工作跟此目录有关 // chains/index goleveldb: 保存了所有通道的最新状态信息 // fileLock goleveldb: 用于锁程序的,文章最末尾有介绍 // historyLeveldb goleveldb: 保存历史交易的 // ledgerProvider goleveldb: 保存的是 chain ids, 也就是通道id // pvtdataStore goleveldb: 存储私有数据库 // stateLeveldb goleveldb: 世界状态数据库, 可以替换为 couchdb // 这两个我不确定没有细追 // configHistory 看名字应该是保存了 config block 相关的东西.</description></item><item><title>Go 删除 Slice 中的某一个值</title><link>https://mioto.me/posts/delete-element-slice/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/delete-element-slice/</guid><description>方法一 优点: 速度最快 缺点: 会导致切片数据顺序改变
a := []string{&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;E&amp;#34;} i := 2 a[i] = a[len(a)-1] // 将数组的最后一位赋值给需要删除的 index 上 a = a[:len(a)-1] // 移除掉最后一个没用的数据 // Output: // [A B E D] 方法二 优点: 速度会随着切片长度改变 缺点: 保持原有切片顺序
a := []string{&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;E&amp;#34;} i := 2 a = append(a[:i], a[i+1:]...) // Output: // [A B D E] Benchmark goos: linux goarch: amd64 pkg: github.com/yakumioto/go-example/benchmark/delete-element-slice Benchmark1 Benchmark1-4 1000000000 0.</description></item><item><title>Fabric 中 etcdraft 共识讲解</title><link>https://mioto.me/posts/etcdraft-exploration-in-fabric-orderer/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/etcdraft-exploration-in-fabric-orderer/</guid><description>为什么要通过 etcdraft 来进行共识?
我觉得有以下原因
solo 并不适合大多数场景, 例如: 组织A, 组织B, 都想在自己放置共识节点 kafka 虽然能满足以上需求, 但是 kafka 加上 zookeeper 需要额外部署并且实在是太重了, 不方便部署 所以基于 etcdraft 的共识来了, 解决了以上的痛点
重要的话说三遍!
千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!!
核心接口 以下是我认为实现 etcdraft 共识核心的接口
// ClusterServer 集群Server接口 type ClusterServer interface { Step(Cluster_StepServer) error } // ClusterClient 集群Client接口 type ClusterClient interface { Step(ctx context.Context, opts ...grpc.CallOption) (orderer.Cluster_StepClient, error) } // Handler 用于共识的两个接口 type Handler interface { OnConsensus(channel string, sender uint64, req *orderer.ConsensusRequest) error OnSubmit(channel string, sender uint64, req *orderer.</description></item><item><title>Go 100 行实现 HTTP(S) 正向代理</title><link>https://mioto.me/posts/http-s-proxy-in-golang-in-less-than-100-lines-of-code/</link><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/http-s-proxy-in-golang-in-less-than-100-lines-of-code/</guid><description>目标是现实一个 HTTP HTTPS 的代理服务器, 目前代理的实现方法有两种
普通代理: 这种代理扮演的是中间人角色, 对于客户端来说, 它就服务器, 对于服务端来说, 它是客户端, 它负责在中间来回传递 HTTP 报文
隧道代理: 它是通过 HTTP 正文部分(body) 完成代理, 以 HTTP 的方式实现基于 TCP 的应用层协议代理, 这种代理使用 HTTP 的 CONNECT 方法建立连接
这是一次 HTTP 的请求, 用 \r\n 进行换行, 碰到连续两个 \r\n 后内容为请求数据, 分为以下几个部分
请求行 (request line) 请求头 (header) 空行 请求数据 (body) curl -Lv http://baidu.com &amp;gt; GET / HTTP/1.1 &amp;gt; Host: baidu.com &amp;gt; User-Agent: curl/7.68.0 &amp;gt; Accept: */* &amp;gt; * Mark bundle as not supporting multiuse &amp;lt; HTTP/1.</description></item><item><title>Go HTTP POST 附件</title><link>https://mioto.me/posts/go-http-post-attachment/</link><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><guid>https://mioto.me/posts/go-http-post-attachment/</guid><description>前段时间为了使用 adb 进行钉钉打卡, 写了个 Go 的程序, 想着万一没打上怎么办, 不如截个图发给自己(现在以 root, 辣鸡钉钉), 文章只为了记录一下实现.
// curl -X POST https://example.com/sendPhoto -F photo=@./screen.png // 以下代码是根据以上 curl 命令的实现 buf := &amp;amp;bytes.Buffer{} mu := multipart.NewWriter(buf) part, err := mu.CreatePart(textproto.MIMEHeader{ &amp;#34;Content-Disposition&amp;#34;: []string{`form-data; name=&amp;#34;photo&amp;#34;; filename=&amp;#34;screen.png&amp;#34;`}, &amp;#34;Content-Type&amp;#34;:[]string{&amp;#34;application/octet-stream&amp;#34;}, }) checkError(err) fp, _ := os.Open(&amp;#34;/home/mioto/screen.png&amp;#34;) io.Copy(part, fp) mu.Close() req, err := http.NewRequest(http.MethodPost, &amp;#34;https://example.com/sendPhoto&amp;#34;, bf) checkError(err) req.Header.Set(&amp;#34;Content-Type&amp;#34;, mu.FormDataContentType()) res, err := http.DefaultClient.Do(req) checkError(err)</description></item><item><title>Go 解析 ECPrivate Key 遇到的问题</title><link>https://mioto.me/posts/go-parse-ec-private-key/</link><pubDate>Tue, 07 May 2019 08:45:00 +0000</pubDate><guid>https://mioto.me/posts/go-parse-ec-private-key/</guid><description>最近在做 fabric 证书私钥管理系统, 遇到的一个问题, 在使用 x509.ParseECPrivateKey() 方法的时候会直接报错, 而 fabric 确实用的是 椭圆曲线算法
错误输出: x509: failed to parse EC private key: asn1: structure error: tags don't match (4 vs {class:0 tag:16 length:19 isCompound:true}) {optional:false explicit:false application:false private:false defaultValue:&amp;lt;nil&amp;gt; tag:&amp;lt;nil&amp;gt; stringType:0 timeType:0 set:false omitEmpty:false} @5
原因是 fabric 将私钥转成 pem 格式的时候使用的方法是 x509.MarshalPKCS8PrivateKey()
解决办法 block, _ := pem.Decode(pemBytes) key, err := x509.ParsePKCS8PrivateKey(block.Bytes) checkErr(err) switch priv := key.(type) { case *ecdsa.PrivateKey: // do something }</description></item><item><title>Go反序列化JSON格式化时间</title><link>https://mioto.me/posts/go-serialize-json-fromat-time/</link><pubDate>Sun, 25 Nov 2018 19:46:00 +0000</pubDate><guid>https://mioto.me/posts/go-serialize-json-fromat-time/</guid><description>默认得到的序列化后的结果是 {&amp;quot;t&amp;quot;:&amp;quot;2018-11-25T20:04:51.362485618+08:00&amp;quot;}, 但如果我想得到 {&amp;quot;t&amp;quot;:&amp;quot;2018-11-25 20:04:51&amp;quot;} 该怎么办呢?
方法一 实现 MarshalJSON 接口, 同时可能也需要反序列化, 所以还需要实现 UnmarshalJSON, 以下代码为实现
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) type Time struct { T time.Time `json:&amp;#34;t,omitempty&amp;#34;` } func (t *Time) MarshalJSON() ([]byte, error) { type alias Time return json.Marshal(struct { *alias T string `json:&amp;#34;t,omitempty&amp;#34;` }{ alias: (*alias)(t), T: t.T.Format(&amp;#34;2006-01-02 15:04:05&amp;#34;), }) } func (t *Time) UnmarshalJSON(data []byte) error { type alias Time tmp := &amp;amp;struct { *alias T string `json:&amp;#34;t,omitempty&amp;#34;` }{ alias: (*alias)(t), } err := json.</description></item><item><title>Go byte 数组转 string</title><link>https://mioto.me/posts/go-bytearray-tostring/</link><pubDate>Sun, 11 Mar 2018 11:01:03 +0000</pubDate><guid>https://mioto.me/posts/go-bytearray-tostring/</guid><description>&lt;p>今天遇到个问题, 如何将 &lt;code>[32]byte&lt;/code> 转 &lt;code>string&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// https://play.golang.org/p/JkK_B5609GN
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">sha256&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sum256&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hahaha&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">hs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// =====
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// [190 23 140 5 67 235 23 245 243 4 48 33 201 229 252 243 2 133 229 87 164 252 48 156 206 151 255 156 166 24 41 18]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go Slice 原理解析</title><link>https://mioto.me/posts/go-slice-analysis/</link><pubDate>Fri, 09 Mar 2018 16:41:51 +0000</pubDate><guid>https://mioto.me/posts/go-slice-analysis/</guid><description>今天被一道题目恶心到了, 发现不研究这些东西可能真的活不下去了, 狠下心来读了一个多小时的源码, 写下些自己对 Slice 的见解吧.
先说说那个题目.
// https://play.golang.org/p/2fA3BylTgtf // 请问 s1 和 s2 的值分别是? func main() { s1 := []int{1, 2, 3} s2 := s1[:0] s2 = append(s2, 4) fmt.Println(s1) fmt.Println(s2) } //========== // [4 2 3] // [4] Slice 定义 先看看 Slice 在 Go 底层的定义
// https://github.com/golang/go/blob/master/src/reflect/value.go#L1806 type sliceHeader struct { Data unsafe.Pointer // Array pointer Len int // slice length Cap int // slice capacity } 原理讲解 第一行 s1 := []int{1, 2, 3} 是将 [1, 2, 3] 的首地址 存入了 Data 中, 设置了 Len 为 3, 设置了 Cap 为 3.</description></item><item><title>Go HTTP JSONRPC Service</title><link>https://mioto.me/posts/go-http-jsonrpc-service/</link><pubDate>Tue, 06 Mar 2018 11:13:31 +0000</pubDate><guid>https://mioto.me/posts/go-http-jsonrpc-service/</guid><description>就贴一段代码&amp;hellip;
package main import ( &amp;#34;bytes&amp;#34; &amp;#34;errors&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/rpc&amp;#34; &amp;#34;net/rpc/jsonrpc&amp;#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(&amp;#34;divide by zero&amp;#34;) } quo.Quo = args.</description></item><item><title>基于 Go 的 RESTful API 怎么设计权限控制</title><link>https://mioto.me/posts/design-permission-control-based-on-restful/</link><pubDate>Thu, 22 Feb 2018 13:53:59 +0000</pubDate><guid>https://mioto.me/posts/design-permission-control-based-on-restful/</guid><description>&lt;p>其实 &lt;code>RESTful API&lt;/code> 实现权限控制的方法很多很多, 比如在每个 &lt;code>Handler&lt;/code> 中进行判断, 但是这种写法会导致工作量无限增加, 万一增加了其他的角色还要不停的更改源码, 所以要以尽量优雅的方式来实现这个部分. 比如 &lt;code>Middleware&lt;/code> 的方式.&lt;/p></description></item><item><title>使用GoBase64标准包遇到的问题</title><link>https://mioto.me/posts/problems-encountered-in-using-gobase64-standard-library/</link><pubDate>Mon, 29 Jan 2018 15:53:07 +0000</pubDate><guid>https://mioto.me/posts/problems-encountered-in-using-gobase64-standard-library/</guid><description>&lt;p>在解析 &lt;code>jwt&lt;/code> 中的 &lt;code>Playload&lt;/code> 部分的 &lt;code>base64&lt;/code> 时遇到了错误.&lt;/p>
&lt;h2 id="报错代码">报错代码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">enstr&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">&amp;#34;eyJBY2NvdW50SWQiOiIxIiwiQ2xpZW50IjoiIiwiRW1haWwiOiJ5YWt1Lm1pb3RvQGdtYWlsLmNvbSIsIk1hc3RlckZsYWciOnRydWUsImV4cCI6MTU0ODc0NTY5OSwidHlwZSI6ImVtcGxveWVlcyJ9&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// {&amp;#34;AccountId&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;Client&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;Email&amp;#34;:&amp;#34;yaku.mioto@gmail.com&amp;#34;,&amp;#34;MasterFlag&amp;#34;:true,&amp;#34;exp&amp;#34;:1548745699,&amp;#34;type&amp;#34;:&amp;#34;employees&amp;#34;}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">debytes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">base64&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StdEncoding&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">DecodeString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">enstr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// err output: illegal base64 data at input byte xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go32位系统计算大于4GB文件sha1遇到的问题</title><link>https://mioto.me/posts/go-the-problem-of-finding-hash-in-32-bit-system/</link><pubDate>Sat, 25 Nov 2017 23:11:39 +0000</pubDate><guid>https://mioto.me/posts/go-the-problem-of-finding-hash-in-32-bit-system/</guid><description>文件大于 4GB 以下方法一定行不通, 32位操作系统 最大的寻址空间就是 4GB
package main import ( &amp;#34;crypto/sha1&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; ) func main() { bytes, err := ioutil.ReadFile(&amp;#34;file.txt&amp;#34;) if err != nil { log.Fatal(err) } h := sha1.New() h.Write(bytes) fmt.Printf(&amp;#34;% x&amp;#34;, h.Sum(nil)) } 以下方法可以算出大于 4GB 文件的 sha1, 但是如果直接表面理解代码, 给人的感觉是无法运行的
io.Copy(h, f) 这里给人的感觉也是一次性读取文件到 h 变量中, &amp;ldquo;给人一种把 整个文件读取到内存的感觉&amp;rdquo;
package main import ( &amp;#34;crypto/sha1&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { f, err := os.Open(&amp;#34;file.txt&amp;#34;) if err != nil { log.</description></item><item><title>Negroni 源码分析</title><link>https://mioto.me/posts/negroni-source-code-analysis/</link><pubDate>Wed, 09 Aug 2017 13:05:00 +0000</pubDate><guid>https://mioto.me/posts/negroni-source-code-analysis/</guid><description>negroni 用了很久很久了, 一直觉得很不错, 目前为止核心源码只有 175 行, 很适合用来学习 Go
初始化 New 将传入的 handlers 构建成链表并保存的过程
type Handler interface { ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) } // middleware 是个单向链表 type middleware struct { handler Handler next *middleware } // Negroni type Negroni struct { middleware middleware // 单向链表 handlers []Handler // 用于存储所有传入的 handler } // New 就是用来构建 middleware 链表的方法 func New(handlers ...Handler) *Negroni { return &amp;amp;Negroni{ handlers: handlers, middleware: build(handlers), } } 这里把传入的 handlers 保存并传给了 build 方法.</description></item></channel></rss>