<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Negroni on 一只麻酱</title><link>https://mioto.me/tags/negroni/</link><description>Recent content in Negroni on 一只麻酱</description><generator>Hugo -- 0.125.4</generator><language>zh</language><lastBuildDate>Wed, 09 Aug 2017 13:05:00 +0000</lastBuildDate><atom:link href="https://mioto.me/tags/negroni/index.xml" rel="self" type="application/rss+xml"/><item><title>Negroni 源码分析</title><link>https://mioto.me/posts/negroni-source-code-analysis/</link><pubDate>Wed, 09 Aug 2017 13:05:00 +0000</pubDate><guid>https://mioto.me/posts/negroni-source-code-analysis/</guid><description>negroni 用了很久很久了, 一直觉得很不错, 目前为止核心源码只有 175 行, 很适合用来学习 Go
初始化 New 将传入的 handlers 构建成链表并保存的过程
type Handler interface { ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) } // middleware 是个单向链表 type middleware struct { handler Handler next *middleware } // Negroni type Negroni struct { middleware middleware // 单向链表 handlers []Handler // 用于存储所有传入的 handler } // New 就是用来构建 middleware 链表的方法 func New(handlers ...Handler) *Negroni { return &amp;amp;Negroni{ handlers: handlers, middleware: build(handlers), } } 这里把传入的 handlers 保存并传给了 build 方法.</description></item></channel></rss>