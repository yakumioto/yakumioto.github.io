<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Hyperledger Fabric on 一只麻酱</title><link>https://mioto.me/tags/hyperledger-fabric/</link><description>Recent content in Hyperledger Fabric on 一只麻酱</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 27 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://mioto.me/tags/hyperledger-fabric/index.xml" rel="self" type="application/rss+xml"/><item><title>Hyperledger Fabric 加入通道时遇到 channel doesn't exist 问题</title><link>https://mioto.me/2020/06/fab-join-channel-issue/</link><pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/2020/06/fab-join-channel-issue/</guid><description>据同事说 node sdk@v2.x.x 版本中没有对网络操作相关的 API 实现, 所以只能自己照着 v1.4.x 版本的 手撸底层代码, 但是在实现 JoinChain 这个功能时出现了 channel doesn't exist 错误
原因 // SignedProposal 部分结构 { &amp;#34;proposal_bytes&amp;#34;: { &amp;#34;header&amp;#34;: { &amp;#34;channel_header&amp;#34;: { &amp;#34;channel_id&amp;#34;: &amp;#34;&amp;#34; }, &amp;#34;signature_header&amp;#34;: { &amp;#34;creator&amp;#34;: { &amp;#34;mspid&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;id_bytes&amp;#34;: &amp;#34;&amp;#34; } } }, &amp;#34;payload&amp;#34;: &amp;#34;&amp;#34; }, &amp;#34;signature&amp;#34;: &amp;#34;&amp;#34; } 当 peer 收到 client 发来的 SignedProposal 时, 会进行签名校验
根据 proposal_bytes.header.channel_header.channel_id 获取对应的 mspMgmtMgr, 如果此时通道不存在, 则会创建一个未经初始化的 mspMgmtMgr 根据 proposal_bytes.header.signature_header.creator.mspid 获取对应的 mspManagerImpl, 但是由于 mspMgmtMgr 未初始化, 所以直接返回了 channel doesn't exist 源码追踪 重要的事情说三遍</description></item><item><title>Hyperledger Fabric peer block 的交付流程详解</title><link>https://mioto.me/2020/06/fab-peer-deliver-block/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/2020/06/fab-peer-deliver-block/</guid><description>本文基于 hyperldeger fabric 1.4.7 进行代码追踪讲解
假设场景描述:
peer 重启场景 peer 有 user channel peer 使用的是 goleveldb peer 的 core.peer.gossip.orgLeader 为 true 流程简介 初始化账本根据账本中保存的 channel id 创建通道实例, 并初始化与之对等的 gossip 服务, 用 来接收对应通道的最新的 配置或交易 block, 接收到 block 后, 经过 Verify, Validate, Validate RW sets 三个验证步骤, 提交给 Ledger Commiter 进行写入文件, 并将当前通道的 blkMgrInfo 更新到最新状态
源码追踪 伊始: main -&amp;gt; node.Cmd -&amp;gt; startCmd -&amp;gt; nodeStartCmd -&amp;gt; serve
peer.Initialize 文件: core/peer/peer.go:241
初始化 ledgermgmt, 里面做的事情太多了, 要讲清楚有点困难建议大家自己去看看, 里面主要做的就是 各种初始化工作
// /var/hyperledger/production/ledgersData 下有这些东西, 这里面的工作跟此目录有关 // chains/index goleveldb: 保存了所有通道的最新状态信息 // fileLock goleveldb: 用于锁程序的,文章最末尾有介绍 // historyLeveldb goleveldb: 保存历史交易的 // ledgerProvider goleveldb: 保存的是 chain ids, 也就是通道id // pvtdataStore goleveldb: 存储私有数据库 // stateLeveldb goleveldb: 世界状态数据库, 可以替换为 couchdb // 这两个我不确定没有细追 // configHistory 看名字应该是保存了 config block 相关的东西.</description></item><item><title>Fabric 中 etcdraft 共识讲解</title><link>https://mioto.me/2020/01/etcdraft-exploration-in-fabric-orderer/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://mioto.me/2020/01/etcdraft-exploration-in-fabric-orderer/</guid><description>为什么要通过 etcdraft 来进行共识?
我觉得有以下原因
solo 并不适合大多数场景, 例如: 组织A, 组织B, 都想在自己放置共识节点 kafka 虽然能满足以上需求, 但是 kafka 加上 zookeeper 需要额外部署并且实在是太重了, 不方便部署 所以基于 etcdraft 的共识来了, 解决了以上的痛点
重要的话说三遍!
千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!! 千万不要错过文章中的源码部分, 里面有很多很多的注释!!!
核心接口 以下是我认为实现 etcdraft 共识核心的接口
// ClusterServer 集群Server接口 type ClusterServer interface { Step(Cluster_StepServer) error } // ClusterClient 集群Client接口 type ClusterClient interface { Step(ctx context.Context, opts ...grpc.CallOption) (orderer.Cluster_StepClient, error) } // Handler 用于共识的两个接口 type Handler interface { OnConsensus(channel string, sender uint64, req *orderer.ConsensusRequest) error OnSubmit(channel string, sender uint64, req *orderer.</description></item></channel></rss>