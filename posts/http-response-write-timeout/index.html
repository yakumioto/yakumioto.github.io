<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go HTTP Response 写超时导致的 EOF 错误 | 一只麻酱</title><meta name=keywords content="Go"><meta name=description content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &#34;http://127.0.0.1:8800&#34;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No."><meta name=author content="Mioto Yaku"><link rel=canonical href=https://mioto.me/posts/http-response-write-timeout/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mioto.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mioto.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mioto.me/favicon-32x32.png><link rel=apple-touch-icon href=https://mioto.me/apple-touch-icon.png><link rel=mask-icon href=https://mioto.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-102233768-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Go HTTP Response 写超时导致的 EOF 错误"><meta property="og:description" content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &#34;http://127.0.0.1:8800&#34;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No."><meta property="og:type" content="article"><meta property="og:url" content="https://mioto.me/posts/http-response-write-timeout/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-10-01T00:00:00+00:00"><meta property="og:site_name" content="一只麻酱"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go HTTP Response 写超时导致的 EOF 错误"><meta name=twitter:description content="前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get &#34;http://127.0.0.1:8800&#34;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行
由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决
原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了
但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error
抓包 源码: https://github.com/yakumioto/demo-response-write-timeout
由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:
客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 &#34;No."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://mioto.me/posts/"},{"@type":"ListItem","position":3,"name":"Go HTTP Response 写超时导致的 EOF 错误","item":"https://mioto.me/posts/http-response-write-timeout/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go HTTP Response 写超时导致的 EOF 错误","name":"Go HTTP Response 写超时导致的 EOF 错误","description":"前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get \u0026quot;http://127.0.0.1:8800\u0026quot;: EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行\n由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决\n原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了\n但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error\n抓包 源码: https://github.com/yakumioto/demo-response-write-timeout\n由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:\n客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 \u0026#34;No.","keywords":["Go"],"articleBody":"前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 Get \"http://127.0.0.1:8800\": EOF, 但是服务端却没有任何 异常 所有的日志都是正常执行\n由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决\n原因 server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了\n但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error\n抓包 源码: https://github.com/yakumioto/demo-response-write-timeout\n由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:\n客户端通过三次握手和服务端建立了 TCP 连接 客户端正常的发送了 HTTP Request 请求 正常的保持了一段时间的 Keep-Alive 服务端通过四次挥手和客户端断开了连接 \"No.\",\"Time\",\"Source\",\"Destination\",\"Protocol\",\"Length\",\"Info\" \"85\",\"3.662590\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"68\",\"55585 \u003e 8800 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=0 SACK_PERM=1\" \"86\",\"3.662666\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"68\",\"8800 \u003e 55585 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=465914251 SACK_PERM=1\" \"87\",\"3.662675\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251\" \"88\",\"3.662681\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Window Update] 8800 \u003e 55585 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251\" \"89\",\"3.662802\",\"127.0.0.1\",\"127.0.0.1\",\"HTTP\",\"151\",\"GET / HTTP/1.1 \" \"90\",\"3.662813\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465914251 TSecr=465914251\" \"160\",\"18.792318\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"161\",\"18.792325\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"162\",\"18.792359\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465929251 TSecr=465914251\" \"163\",\"18.792363\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#1] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465929251 TSecr=465914251\" \"283\",\"33.925723\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"284\",\"33.925731\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"285\",\"33.925741\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465944251 TSecr=465929251\" \"286\",\"33.925749\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#2] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465944251 TSecr=465929251\" \"345\",\"49.031897\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 8800 \u003e 55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0\" \"346\",\"49.031903\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"44\",\"[TCP Keep-Alive] 55585 \u003e 8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0\" \"347\",\"49.031929\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Keep-Alive ACK] 55585 \u003e 8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465959251 TSecr=465944251\" \"348\",\"49.031932\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"[TCP Dup ACK 90#3] 8800 \u003e 55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465959251 TSecr=465944251\" \"469\",\"63.667058\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [FIN, ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465973767 TSecr=465959251\" \"470\",\"63.667081\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767\" \"471\",\"63.667119\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"55585 \u003e 8800 [FIN, ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767\" \"472\",\"63.667147\",\"127.0.0.1\",\"127.0.0.1\",\"TCP\",\"56\",\"8800 \u003e 55585 [ACK] Seq=2 Ack=97 Win=408192 Len=0 TSval=465973767 TSecr=465973767\" 源码解析 既然是源码分析那就从头跟起!!!\n入口方法, 为了方便定位追踪源码 // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2854 // 入口函数, 没啥好解释的 func (srv *Server) ListenAndServe() error { ... return srv.Serve(ln) } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2907 // 死循环, 监听请求, 并开一个协程处理 func (srv *Server) Serve(l net.Listener) error { ... for { ... c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(connCtx) } } 这里有一些重要的变量需要记录以下, 后续的源码中会涉及到 b.bufr: conn 的读 buffer b.bufw: conn 的写 buffer, 大小为 4096 byte c.readRequest(ctx): 处理了 req 请求, 同时返回了一个 *response ServeHTTP(w, w.req): 最终 w 会一路下传, 到我们自己所写的处理函数中\n接下来就看这个 w 是如何产生的\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:1794 func (c *conn) serve(ctx context.Context) { ... // HTTP/1.x from here on. ctx, cancelCtx := context.WithCancel(ctx) c.cancelCtx = cancelCtx defer cancelCtx() c.r = \u0026connReader{conn: c} c.bufr = newBufioReader(c.r) c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4\u003c\u003c10) for { w, err := c.readRequest(ctx) ... serverHandler{c.server}.ServeHTTP(w, w.req) ... } } w.w: 可见 w.w 是 w.cw 的 bufio.Writer 相当于调用 w.w.Write(p []byte) == w.cw.Write(p []byte) w.cw: 可见其类型是 chunkWriter 所以如果调用到 w.w.Write(p []byte) == chunkWriter.Write([]byte)\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:418 type response struct { ... w *bufio.Writer // buffers output in chunks to chunkWriter cw chunkWriter ... } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:955 func (c *conn) readRequest(ctx context.Context) (w *response, err error) { ... w = \u0026response{ conn: c, cancelCtx: cancelCtx, req: req, reqBody: req.Body, handlerHeader: make(Header), contentLength: -1, closeNotifyCh: make(chan bool, 1), // We populate these ahead of time so we're not // reading from req.Header after their Handler starts // and maybe mutates it (Issue 14940) wants10KeepAlive: req.wantsHttp10KeepAlive(), wantsClose: req.wantsClose(), } if isH2Upgrade { w.closeAfterReply = true } w.cw.res = w w.w = newBufioWriterSize(\u0026w.cw, bufferBeforeChunkingSize) ... } cw.res.conn: 根据上面的代码发现 conn == w.conn == srv.newConn(rw) cw.res.conn.bufw: 就是 c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4«10), 由此可见 conn write 的缓冲区就是 4096 byte\nfunc (cw *chunkWriter) Write(p []byte) (n int, err error) { ... n, err = cw.res.conn.bufw.Write(p) if cw.chunking \u0026\u0026 err == nil { _, err = cw.res.conn.bufw.Write(crlf) } if err != nil { cw.res.conn.rwc.Close() } return } bufio: 如果数据长度没有超过 len(b.buf) 数据会 copy 到 b.buf 中, 并不会真正写入 b.wr 中\n// file: /usr/local/Cellar/go/1.15.2/libexec/src/bufio/bufio.go:558 type Writer struct { err error buf []byte n int wr io.Writer } // file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:368 func (b *Writer) Write(p []byte) (nn int, err error) { for len(p) \u003e b.Available() \u0026\u0026 b.err == nil { var n int if b.Buffered() == 0 { // Large write, empty buffer. // Write directly from p to avoid copy. n, b.err = b.wr.Write(p) } else { n = copy(b.buf[b.n:], p) b.n += n b.Flush() } nn += n p = p[n:] } if b.err != nil { return nn, b.err } n := copy(b.buf[b.n:], p) b.n += n nn += n return nn, nil } 参考 https://github.com/golang/go/issues/21389 ","wordCount":"745","inLanguage":"zh","datePublished":"2020-10-01T00:00:00Z","dateModified":"2020-10-01T00:00:00Z","author":{"@type":"Person","name":"Mioto Yaku"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mioto.me/posts/http-response-write-timeout/"},"publisher":{"@type":"Organization","name":"一只麻酱","logo":{"@type":"ImageObject","url":"https://mioto.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mioto.me accesskey=h title="一只麻酱 (Alt + H)">一只麻酱</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mioto.me/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mioto.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go HTTP Response 写超时导致的 EOF 错误</h1><div class=post-meta><span title='2020-10-01 00:00:00 +0000 UTC'>十月 1, 2020</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Mioto Yaku</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%8e%9f%e5%9b%a0 aria-label=原因>原因</a></li><li><a href=#%e6%8a%93%e5%8c%85 aria-label=抓包>抓包</a></li><li><a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-label=源码解析>源码解析</a><ul><li><a href=#%e5%85%a5%e5%8f%a3%e6%96%b9%e6%b3%95-%e4%b8%ba%e4%ba%86%e6%96%b9%e4%be%bf%e5%ae%9a%e4%bd%8d%e8%bf%bd%e8%b8%aa%e6%ba%90%e7%a0%81 aria-label="入口方法, 为了方便定位追踪源码">入口方法, 为了方便定位追踪源码</a></li><li><a href=#%e8%bf%99%e9%87%8c%e6%9c%89%e4%b8%80%e4%ba%9b%e9%87%8d%e8%a6%81%e7%9a%84%e5%8f%98%e9%87%8f%e9%9c%80%e8%a6%81%e8%ae%b0%e5%bd%95%e4%bb%a5%e4%b8%8b-%e5%90%8e%e7%bb%ad%e7%9a%84%e6%ba%90%e7%a0%81%e4%b8%ad%e4%bc%9a%e6%b6%89%e5%8f%8a%e5%88%b0 aria-label="这里有一些重要的变量需要记录以下, 后续的源码中会涉及到">这里有一些重要的变量需要记录以下, 后续的源码中会涉及到</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><p>前天在联调过程中出现了一个神奇的错误, 错误在 client 端的表现为 http 请求错误 <code>Get "http://127.0.0.1:8800": EOF</code>, 但是服务端却没有任何 <strong>异常</strong> 所有的日志都是正常执行</p><p>由于只有 client 端的错误, 所以 Google 搜索的处理结果全都不是实际场景导致的(并没有怀疑到服务端出了问题), 无奈只能抓包, 最终问题得以解决</p><h2 id=原因>原因<a hidden class=anchor aria-hidden=true href=#原因>#</a></h2><p>server 端处理请求耗时 30s, 但是 http.Server 的 write timeout 设置的时间是 10s, 所以在 handler 处理请求完毕的时候, server 端和 client 端的连接已经被关闭了</p><p>但是由于 server 端写入的 data 远远小于 http/net 包中设定的 write buffer 缓冲大小(4096 byte), 所以 bufio 的 Write 方法并没有返回 error</p><h2 id=抓包>抓包<a hidden class=anchor aria-hidden=true href=#抓包>#</a></h2><p>源码: <a href=https://github.com/yakumioto/demo-response-write-timeout>https://github.com/yakumioto/demo-response-write-timeout</a></p><p>由于测试环境太过复杂, 所以写了个 demo 复现了整个流程， 以下是 wireshark 导出的 svc 由此可以看出:</p><ol><li>客户端通过三次握手和服务端建立了 TCP 连接</li><li>客户端正常的发送了 HTTP Request 请求</li><li>正常的保持了一段时间的 Keep-Alive</li><li>服务端通过四次挥手和客户端断开了连接</li></ol><pre tabindex=0><code class=language-svc data-lang=svc>&#34;No.&#34;,&#34;Time&#34;,&#34;Source&#34;,&#34;Destination&#34;,&#34;Protocol&#34;,&#34;Length&#34;,&#34;Info&#34;
&#34;85&#34;,&#34;3.662590&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;68&#34;,&#34;55585  &gt;  8800 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=0 SACK_PERM=1&#34;
&#34;86&#34;,&#34;3.662666&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;68&#34;,&#34;8800  &gt;  55585 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=465914251 TSecr=465914251 SACK_PERM=1&#34;
&#34;87&#34;,&#34;3.662675&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;88&#34;,&#34;3.662681&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Window Update] 8800  &gt;  55585 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;89&#34;,&#34;3.662802&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;HTTP&#34;,&#34;151&#34;,&#34;GET / HTTP/1.1 &#34;
&#34;90&#34;,&#34;3.662813&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465914251 TSecr=465914251&#34;
&#34;160&#34;,&#34;18.792318&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;161&#34;,&#34;18.792325&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;162&#34;,&#34;18.792359&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465929251 TSecr=465914251&#34;
&#34;163&#34;,&#34;18.792363&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#1] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465929251 TSecr=465914251&#34;
&#34;283&#34;,&#34;33.925723&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;284&#34;,&#34;33.925731&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;285&#34;,&#34;33.925741&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465944251 TSecr=465929251&#34;
&#34;286&#34;,&#34;33.925749&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#2] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465944251 TSecr=465929251&#34;
&#34;345&#34;,&#34;49.031897&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 8800  &gt;  55585 [ACK] Seq=0 Ack=96 Win=408192 Len=0&#34;
&#34;346&#34;,&#34;49.031903&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;44&#34;,&#34;[TCP Keep-Alive] 55585  &gt;  8800 [ACK] Seq=95 Ack=1 Win=408256 Len=0&#34;
&#34;347&#34;,&#34;49.031929&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Keep-Alive ACK] 55585  &gt;  8800 [ACK] Seq=96 Ack=1 Win=408256 Len=0 TSval=465959251 TSecr=465944251&#34;
&#34;348&#34;,&#34;49.031932&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;[TCP Dup ACK 90#3] 8800  &gt;  55585 [ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465959251 TSecr=465944251&#34;
&#34;469&#34;,&#34;63.667058&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [FIN, ACK] Seq=1 Ack=96 Win=408192 Len=0 TSval=465973767 TSecr=465959251&#34;
&#34;470&#34;,&#34;63.667081&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767&#34;
&#34;471&#34;,&#34;63.667119&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;55585  &gt;  8800 [FIN, ACK] Seq=96 Ack=2 Win=408256 Len=0 TSval=465973767 TSecr=465973767&#34;
&#34;472&#34;,&#34;63.667147&#34;,&#34;127.0.0.1&#34;,&#34;127.0.0.1&#34;,&#34;TCP&#34;,&#34;56&#34;,&#34;8800  &gt;  55585 [ACK] Seq=2 Ack=97 Win=408192 Len=0 TSval=465973767 TSecr=465973767&#34;
</code></pre><h2 id=源码解析>源码解析<a hidden class=anchor aria-hidden=true href=#源码解析>#</a></h2><p>既然是源码分析那就从头跟起!!!</p><h3 id=入口方法-为了方便定位追踪源码>入口方法, 为了方便定位追踪源码<a hidden class=anchor aria-hidden=true href=#入口方法-为了方便定位追踪源码>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2854
</span></span></span><span class=line><span class=cl><span class=c1>// 入口函数, 没啥好解释的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>srv</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>ListenAndServe</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>srv</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>ln</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:2907
</span></span></span><span class=line><span class=cl><span class=c1>// 死循环, 监听请求, 并开一个协程处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>srv</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>Serve</span><span class=p>(</span><span class=nx>l</span> <span class=nx>net</span><span class=p>.</span><span class=nx>Listener</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span> <span class=o>:=</span> <span class=nx>srv</span><span class=p>.</span><span class=nf>newConn</span><span class=p>(</span><span class=nx>rw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nf>setState</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>rwc</span><span class=p>,</span> <span class=nx>StateNew</span><span class=p>)</span> <span class=c1>// before Serve can return
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>go</span> <span class=nx>c</span><span class=p>.</span><span class=nf>serve</span><span class=p>(</span><span class=nx>connCtx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=这里有一些重要的变量需要记录以下-后续的源码中会涉及到>这里有一些重要的变量需要记录以下, 后续的源码中会涉及到<a hidden class=anchor aria-hidden=true href=#这里有一些重要的变量需要记录以下-后续的源码中会涉及到>#</a></h3><p><code>b.bufr</code>: conn 的读 buffer
<code>b.bufw</code>: conn 的写 buffer, 大小为 4096 byte
<code>c.readRequest(ctx)</code>: 处理了 req 请求, 同时返回了一个 <code>*response</code>
<code>ServeHTTP(w, w.req)</code>: 最终 w 会一路下传, 到我们自己所写的处理函数中</p><p>接下来就看这个 <code>w</code> 是如何产生的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:1794
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>conn</span><span class=p>)</span> <span class=nf>serve</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// HTTP/1.x from here on.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancelCtx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>cancelCtx</span> <span class=p>=</span> <span class=nx>cancelCtx</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>cancelCtx</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>r</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>connReader</span><span class=p>{</span><span class=nx>conn</span><span class=p>:</span> <span class=nx>c</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>bufr</span> <span class=p>=</span> <span class=nf>newBufioReader</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>bufw</span> <span class=p>=</span> <span class=nf>newBufioWriterSize</span><span class=p>(</span><span class=nx>checkConnErrorWriter</span><span class=p>{</span><span class=nx>c</span><span class=p>},</span> <span class=mi>4</span><span class=o>&lt;&lt;</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>w</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>readRequest</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=nx>serverHandler</span><span class=p>{</span><span class=nx>c</span><span class=p>.</span><span class=nx>server</span><span class=p>}.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>w</span><span class=p>.</span><span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>w.w</code>: 可见 w.w 是 w.cw 的 bufio.Writer 相当于调用 w.w.Write(p []byte) == w.cw.Write(p []byte)
<code>w.cw</code>: 可见其类型是 chunkWriter 所以如果调用到 w.w.Write(p []byte) == chunkWriter.Write([]byte)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:418
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>response</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span>  <span class=o>*</span><span class=nx>bufio</span><span class=p>.</span><span class=nx>Writer</span> <span class=c1>// buffers output in chunks to chunkWriter
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cw</span> <span class=nx>chunkWriter</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:955
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>conn</span><span class=p>)</span> <span class=nf>readRequest</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>response</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>response</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span><span class=p>:</span>          <span class=nx>c</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>cancelCtx</span><span class=p>:</span>     <span class=nx>cancelCtx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>req</span><span class=p>:</span>           <span class=nx>req</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>reqBody</span><span class=p>:</span>       <span class=nx>req</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>handlerHeader</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Header</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nx>contentLength</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>closeNotifyCh</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We populate these ahead of time so we&#39;re not
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// reading from req.Header after their Handler starts
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// and maybe mutates it (Issue 14940)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>wants10KeepAlive</span><span class=p>:</span> <span class=nx>req</span><span class=p>.</span><span class=nf>wantsHttp10KeepAlive</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nx>wantsClose</span><span class=p>:</span>       <span class=nx>req</span><span class=p>.</span><span class=nf>wantsClose</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>isH2Upgrade</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>w</span><span class=p>.</span><span class=nx>closeAfterReply</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nx>cw</span><span class=p>.</span><span class=nx>res</span> <span class=p>=</span> <span class=nx>w</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nx>w</span> <span class=p>=</span> <span class=nf>newBufioWriterSize</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>w</span><span class=p>.</span><span class=nx>cw</span><span class=p>,</span> <span class=nx>bufferBeforeChunkingSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>cw.res.conn</code>: 根据上面的代码发现 conn == w.conn == srv.newConn(rw)
<code>cw.res.conn.bufw</code>: 就是 c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&#171;10), 由此可见 conn write 的缓冲区就是 4096 byte</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>cw</span> <span class=o>*</span><span class=nx>chunkWriter</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>cw</span><span class=p>.</span><span class=nx>res</span><span class=p>.</span><span class=nx>conn</span><span class=p>.</span><span class=nx>bufw</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cw</span><span class=p>.</span><span class=nx>chunking</span> <span class=o>&amp;&amp;</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>cw</span><span class=p>.</span><span class=nx>res</span><span class=p>.</span><span class=nx>conn</span><span class=p>.</span><span class=nx>bufw</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>crlf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cw</span><span class=p>.</span><span class=nx>res</span><span class=p>.</span><span class=nx>conn</span><span class=p>.</span><span class=nx>rwc</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>bufio</code>: 如果数据长度没有超过 len(b.buf) 数据会 copy 到 b.buf 中, 并不会真正写入 b.wr 中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/bufio/bufio.go:558
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Writer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>wr</span>  <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file: /usr/local/Cellar/go/1.15.2/libexec/src/net/http/server.go:368
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>nn</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>b</span><span class=p>.</span><span class=nf>Available</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>n</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nf>Buffered</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Large write, empty buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// Write directly from p to avoid copy.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>n</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>err</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>wr</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>n</span> <span class=p>=</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>buf</span><span class=p>[</span><span class=nx>b</span><span class=p>.</span><span class=nx>n</span><span class=p>:],</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span><span class=p>.</span><span class=nx>n</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span><span class=p>.</span><span class=nf>Flush</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>nn</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>        <span class=nx>p</span> <span class=p>=</span> <span class=nx>p</span><span class=p>[</span><span class=nx>n</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>buf</span><span class=p>[</span><span class=nx>b</span><span class=p>.</span><span class=nx>n</span><span class=p>:],</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span><span class=p>.</span><span class=nx>n</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=nx>nn</span> <span class=o>+=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>nn</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://github.com/golang/go/issues/21389>https://github.com/golang/go/issues/21389</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://mioto.me/tags/go/>Go</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//yakumioto.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://mioto.me>一只麻酱</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>