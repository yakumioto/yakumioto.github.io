<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建 | 一只麻酱</title>
<meta name=keywords content="Docker"><meta name=description content="在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。
在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。
通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。
详细步骤与命令解释 1. 准备所需镜像 首先，我们需要准备两个关键镜像：
registry:latest：用于搭建本地 Docker Registry。 moby/buildkit:buildx-stable-1：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。 2. 启动 Docker Registry 使用以下命令启动一个本地 Docker Registry：
docker run -itd -v $(pwd)/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest -v $(pwd)/registry:/var/lib/registry：将宿主机上的 $(pwd)/registry 目录挂载到容器内的 /var/lib/registry 目录，用于持久化存储镜像数据。 -p 5000:5000：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。 --restart=always：设置容器在启动时总是重启，确保 Registry 服务的可用性。 --name registry：为容器指定一个名称，方便后续管理。 3."><meta name=author content="Mioto Yaku"><link rel=canonical href=https://mioto.me/posts/offline-docker-buildx-and-registry-for-multi-platform-image-building/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://mioto.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mioto.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mioto.me/favicon-32x32.png><link rel=apple-touch-icon href=https://mioto.me/apple-touch-icon.png><link rel=mask-icon href=https://mioto.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://mioto.me/posts/offline-docker-buildx-and-registry-for-multi-platform-image-building/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建"><meta property="og:description" content="在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。
在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。
通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。
详细步骤与命令解释 1. 准备所需镜像 首先，我们需要准备两个关键镜像：
registry:latest：用于搭建本地 Docker Registry。 moby/buildkit:buildx-stable-1：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。 2. 启动 Docker Registry 使用以下命令启动一个本地 Docker Registry：
docker run -itd -v $(pwd)/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest -v $(pwd)/registry:/var/lib/registry：将宿主机上的 $(pwd)/registry 目录挂载到容器内的 /var/lib/registry 目录，用于持久化存储镜像数据。 -p 5000:5000：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。 --restart=always：设置容器在启动时总是重启，确保 Registry 服务的可用性。 --name registry：为容器指定一个名称，方便后续管理。 3."><meta property="og:type" content="article"><meta property="og:url" content="https://mioto.me/posts/offline-docker-buildx-and-registry-for-multi-platform-image-building/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-28T18:16:29+08:00"><meta property="article:modified_time" content="2024-04-28T18:16:29+08:00"><meta property="og:site_name" content="一只麻酱"><meta name=twitter:card content="summary"><meta name=twitter:title content="离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建"><meta name=twitter:description content="在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。
在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。
通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。
详细步骤与命令解释 1. 准备所需镜像 首先，我们需要准备两个关键镜像：
registry:latest：用于搭建本地 Docker Registry。 moby/buildkit:buildx-stable-1：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。 2. 启动 Docker Registry 使用以下命令启动一个本地 Docker Registry：
docker run -itd -v $(pwd)/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest -v $(pwd)/registry:/var/lib/registry：将宿主机上的 $(pwd)/registry 目录挂载到容器内的 /var/lib/registry 目录，用于持久化存储镜像数据。 -p 5000:5000：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。 --restart=always：设置容器在启动时总是重启，确保 Registry 服务的可用性。 --name registry：为容器指定一个名称，方便后续管理。 3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mioto.me/posts/"},{"@type":"ListItem","position":2,"name":"离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建","item":"https://mioto.me/posts/offline-docker-buildx-and-registry-for-multi-platform-image-building/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建","name":"离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建","description":"在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。\n在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。\n通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。\n详细步骤与命令解释 1. 准备所需镜像 首先，我们需要准备两个关键镜像：\nregistry:latest：用于搭建本地 Docker Registry。 moby/buildkit:buildx-stable-1：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。 2. 启动 Docker Registry 使用以下命令启动一个本地 Docker Registry：\ndocker run -itd -v $(pwd)/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest -v $(pwd)/registry:/var/lib/registry：将宿主机上的 $(pwd)/registry 目录挂载到容器内的 /var/lib/registry 目录，用于持久化存储镜像数据。 -p 5000:5000：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。 --restart=always：设置容器在启动时总是重启，确保 Registry 服务的可用性。 --name registry：为容器指定一个名称，方便后续管理。 3.","keywords":["Docker"],"articleBody":"在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。\n在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。\n通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。\n详细步骤与命令解释 1. 准备所需镜像 首先，我们需要准备两个关键镜像：\nregistry:latest：用于搭建本地 Docker Registry。 moby/buildkit:buildx-stable-1：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。 2. 启动 Docker Registry 使用以下命令启动一个本地 Docker Registry：\ndocker run -itd -v $(pwd)/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest -v $(pwd)/registry:/var/lib/registry：将宿主机上的 $(pwd)/registry 目录挂载到容器内的 /var/lib/registry 目录，用于持久化存储镜像数据。 -p 5000:5000：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。 --restart=always：设置容器在启动时总是重启，确保 Registry 服务的可用性。 --name registry：为容器指定一个名称，方便后续管理。 3. 创建 Docker Buildx 构建器 3.1 重命名并推送 BuildKit 镜像到本地 Registry 假设宿主机的 IP 地址为 192.168.10.10，我们需要将 moby/buildkit:buildx-stable-1 镜像重命名并推送到本地 Registry：\ndocker tag moby/buildkit:buildx-stable-1 192.168.10.10:5000/moby/buildkit:buildx-stable-1 docker push 192.168.10.10:5000/moby/buildkit:buildx-stable-1 如果遇到推送镜像到本地 Registry 的问题，可以将 192.168.10.10:5000 添加到 Docker 守护进程的配置文件 /etc/docker/daemon.json 中：\n{ \"insecure-registries\": [\"192.168.10.10:5000\"] } 3.2 创建 BuildKit 配置文件 创建 BuildKit 配置文件 /root/.docker/buildx/buildkitd.default.toml，内容如下：\n[registry.\"192.168.10.10:5000\"] http = true insecure = true 这个配置文件指定了使用本地 Registry 时的一些设置，如允许使用 HTTP 协议和忽略 SSL 证书验证。\n3.3 创建 Docker Buildx 构建器 使用以下命令创建一个名为 cross-builder 的 Docker Buildx 构建器：\ndocker buildx create --use --platform linux/amd64,linux/arm64 --name cross-builder --driver docker-container --driver-opt image=192.168.10.10:5000/moby/buildkit:buildx-stable-1 --buildkitd-config ~/.docker/buildx/buildkitd.default.toml --bootstrap --use：创建构建器后立即切换为当前使用的构建器。 --platform linux/amd64,linux/arm64：指定支持的目标平台，这里支持 linux/amd64 和 linux/arm64 两个平台。 --name cross-builder：指定构建器的名称。 --driver docker-container：使用 docker-container 驱动，即在容器中运行 BuildKit。 --driver-opt image=192.168.10.10:5000/moby/buildkit:buildx-stable-1：指定使用的 BuildKit 镜像。 --buildkitd-config /root/.docker/buildx/buildkitd.default.toml：指定 BuildKit 的配置文件。 --bootstrap: 直接初始化此构建器 3.4 验证构建器状态 使用以下命令验证构建器状态：\ndocker buildx ls 输出结果应该类似于：\nNAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMS cross-builder* docker-container \\_ cross-builder0 \\_ unix:///var/run/docker.sock running v0.13.2 linux/amd64*, linux/arm64*, linux/amd64/v2, linux/amd64/v3, linux/386 default docker \\_ default \\_ default running v0.13.1 linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/386 4. 使用本地 Registry 的技巧 为了高效地使用本地 Registry，我们可以将不同平台的镜像推送到 Registry 中，并使用 Docker Manifest 将它们聚合为一个多平台镜像。\n以 Ubuntu 24.04 为例，假设我们已经在本地拉取了 linux/amd64 和 linux/arm64 两个平台的镜像：\n# 拉取 linux/amd64 平台的 Ubuntu 24.04 镜像 docker pull --platform linux/amd64 ubuntu:24.04 # 重命名镜像并推送到本地 Registry docker tag ubuntu:24.04 192.168.10.10:5000/ubuntu-amd64:24.04 docker push 192.168.10.10:5000/ubuntu-amd64:24.04 # 拉取 linux/arm64 平台的 Ubuntu 24.04 镜像 docker pull --platform linux/arm64 ubuntu:24.04 # 重命名镜像并推送到本地 Registry docker tag ubuntu:24.04 192.168.10.10:5000/ubuntu-arm64:24.04 docker push 192.168.10.10:5000/ubuntu-arm64:24.04 接下来，使用 Docker Manifest 将这两个平台的镜像聚合为一个多平台镜像：\ndocker manifest create --insecure 192.168.10.10:5000/ubuntu:24.04 192.168.10.10:5000/ubuntu-amd64:24.04 192.168.10.10:5000/ubuntu-arm64:24.04 docker manifest push --insecure 192.168.10.10:5000/ubuntu:24.04 现在，我们就可以在构建多平台镜像时，直接从本地 Registry 拉取 192.168.10.10:5000/ubuntu:24.04 镜像，而无需考虑具体的平台。\n总结 在离线环境下构建多平台 Docker 镜像具有一定的挑战性，但通过合理使用 Docker Buildx 和 Docker Registry，我们可以高效地实现这一目标。本文详细介绍了相关的步骤和命令，希望对您在离线环境下的 Docker 镜像构建工作有所帮助。\n参考 https://docs.docker.com/reference/cli/docker/buildx/ https://github.com/docker/buildx/discussions/1088 https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md https://community.arm.com/arm-community-blogs/b/tools-software-ides-blog/posts/deploying-multi-architecture-docker-registry ","wordCount":"323","inLanguage":"zh","datePublished":"2024-04-28T18:16:29+08:00","dateModified":"2024-04-28T18:16:29+08:00","author":{"@type":"Person","name":"Mioto Yaku"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mioto.me/posts/offline-docker-buildx-and-registry-for-multi-platform-image-building/"},"publisher":{"@type":"Organization","name":"一只麻酱","logo":{"@type":"ImageObject","url":"https://mioto.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mioto.me/ accesskey=h title="一只麻酱 (Alt + H)">一只麻酱</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mioto.me/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mioto.me/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建</h1><div class=post-meta><span title='2024-04-28 18:16:29 +0800 +0800'>四月 28, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Mioto Yaku</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e8%af%a6%e7%bb%86%e6%ad%a5%e9%aa%a4%e4%b8%8e%e5%91%bd%e4%bb%a4%e8%a7%a3%e9%87%8a aria-label=详细步骤与命令解释>详细步骤与命令解释</a><ul><li><a href=#1-%e5%87%86%e5%a4%87%e6%89%80%e9%9c%80%e9%95%9c%e5%83%8f aria-label="1. 准备所需镜像">1. 准备所需镜像</a></li><li><a href=#2-%e5%90%af%e5%8a%a8-docker-registry aria-label="2. 启动 Docker Registry">2. 启动 Docker Registry</a></li><li><a href=#3-%e5%88%9b%e5%bb%ba-docker-buildx-%e6%9e%84%e5%bb%ba%e5%99%a8 aria-label="3. 创建 Docker Buildx 构建器">3. 创建 Docker Buildx 构建器</a><ul><li><a href=#31-%e9%87%8d%e5%91%bd%e5%90%8d%e5%b9%b6%e6%8e%a8%e9%80%81-buildkit-%e9%95%9c%e5%83%8f%e5%88%b0%e6%9c%ac%e5%9c%b0-registry aria-label="3.1 重命名并推送 BuildKit 镜像到本地 Registry">3.1 重命名并推送 BuildKit 镜像到本地 Registry</a></li><li><a href=#32-%e5%88%9b%e5%bb%ba-buildkit-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-label="3.2 创建 BuildKit 配置文件">3.2 创建 BuildKit 配置文件</a></li><li><a href=#33-%e5%88%9b%e5%bb%ba-docker-buildx-%e6%9e%84%e5%bb%ba%e5%99%a8 aria-label="3.3 创建 Docker Buildx 构建器">3.3 创建 Docker Buildx 构建器</a></li><li><a href=#34-%e9%aa%8c%e8%af%81%e6%9e%84%e5%bb%ba%e5%99%a8%e7%8a%b6%e6%80%81 aria-label="3.4 验证构建器状态">3.4 验证构建器状态</a></li></ul></li><li><a href=#4-%e4%bd%bf%e7%94%a8%e6%9c%ac%e5%9c%b0-registry-%e7%9a%84%e6%8a%80%e5%b7%a7 aria-label="4. 使用本地 Registry 的技巧">4. 使用本地 Registry 的技巧</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><p>在软件开发与部署过程中，我们经常需要构建适用于不同平台和架构的 Docker 镜像。然而，在离线环境下，由于无法访问互联网，构建多平台镜像变得颇具挑战。本文将介绍如何在离线环境下使用 Docker Buildx 与 Docker Registry 实现多平台镜像构建。</p><p>在离线环境下，我们无法安装 QEMU 环境，所以只能采用基于容器的 BuildX 环境，而基于容器的 Buildx 环境并不会从本地的Docker中查询镜像，而是从远端拉取镜像。因此，我们需要事先准备好所需的镜像，并在本地搭建一个 Docker Registry 用于存储和分发这些镜像。</p><p>通过结合使用 Docker Buildx 与本地 Docker Registry，我们可以在离线环境下高效地构建和分发多平台 Docker 镜像。</p><h2 id=详细步骤与命令解释>详细步骤与命令解释<a hidden class=anchor aria-hidden=true href=#详细步骤与命令解释>#</a></h2><h3 id=1-准备所需镜像>1. 准备所需镜像<a hidden class=anchor aria-hidden=true href=#1-准备所需镜像>#</a></h3><p>首先，我们需要准备两个关键镜像：</p><ul><li><code>registry:latest</code>：用于搭建本地 Docker Registry。</li><li><code>moby/buildkit:buildx-stable-1</code>：包含了 Docker Buildx 所需的 BuildKit 和 QEMU，用于支持多平台构建。</li></ul><h3 id=2-启动-docker-registry>2. 启动 Docker Registry<a hidden class=anchor aria-hidden=true href=#2-启动-docker-registry>#</a></h3><p>使用以下命令启动一个本地 Docker Registry：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -itd -v <span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span>/registry:/var/lib/registry -p 5000:5000 --restart<span class=o>=</span>always --name registry registry:latest
</span></span></code></pre></div><ul><li><code>-v $(pwd)/registry:/var/lib/registry</code>：将宿主机上的 <code>$(pwd)/registry</code> 目录挂载到容器内的 <code>/var/lib/registry</code> 目录，用于持久化存储镜像数据。</li><li><code>-p 5000:5000</code>：将容器内的 5000 端口映射到宿主机的 5000 端口，允许从宿主机访问 Registry。</li><li><code>--restart=always</code>：设置容器在启动时总是重启，确保 Registry 服务的可用性。</li><li><code>--name registry</code>：为容器指定一个名称，方便后续管理。</li></ul><h3 id=3-创建-docker-buildx-构建器>3. 创建 Docker Buildx 构建器<a hidden class=anchor aria-hidden=true href=#3-创建-docker-buildx-构建器>#</a></h3><h4 id=31-重命名并推送-buildkit-镜像到本地-registry>3.1 重命名并推送 BuildKit 镜像到本地 Registry<a hidden class=anchor aria-hidden=true href=#31-重命名并推送-buildkit-镜像到本地-registry>#</a></h4><p>假设宿主机的 IP 地址为 <code>192.168.10.10</code>，我们需要将 <code>moby/buildkit:buildx-stable-1</code> 镜像重命名并推送到本地 Registry：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker tag moby/buildkit:buildx-stable-1 192.168.10.10:5000/moby/buildkit:buildx-stable-1
</span></span><span class=line><span class=cl>docker push 192.168.10.10:5000/moby/buildkit:buildx-stable-1
</span></span></code></pre></div><p>如果遇到推送镜像到本地 Registry 的问题，可以将 <code>192.168.10.10:5000</code> 添加到 Docker 守护进程的配置文件 <code>/etc/docker/daemon.json</code> 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;insecure-registries&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;192.168.10.10:5000&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=32-创建-buildkit-配置文件>3.2 创建 BuildKit 配置文件<a hidden class=anchor aria-hidden=true href=#32-创建-buildkit-配置文件>#</a></h4><p>创建 BuildKit 配置文件 <code>/root/.docker/buildx/buildkitd.default.toml</code>，内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=p>[</span><span class=nx>registry</span><span class=p>.</span><span class=s2>&#34;192.168.10.10:5000&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>http</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=nx>insecure</span> <span class=p>=</span> <span class=kc>true</span>
</span></span></code></pre></div><p>这个配置文件指定了使用本地 Registry 时的一些设置，如允许使用 HTTP 协议和忽略 SSL 证书验证。</p><h4 id=33-创建-docker-buildx-构建器>3.3 创建 Docker Buildx 构建器<a hidden class=anchor aria-hidden=true href=#33-创建-docker-buildx-构建器>#</a></h4><p>使用以下命令创建一个名为 <code>cross-builder</code> 的 Docker Buildx 构建器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker buildx create --use --platform linux/amd64,linux/arm64 --name cross-builder --driver docker-container --driver-opt <span class=nv>image</span><span class=o>=</span>192.168.10.10:5000/moby/buildkit:buildx-stable-1 --buildkitd-config ~/.docker/buildx/buildkitd.default.toml --bootstrap
</span></span></code></pre></div><ul><li><code>--use</code>：创建构建器后立即切换为当前使用的构建器。</li><li><code>--platform linux/amd64,linux/arm64</code>：指定支持的目标平台，这里支持 <code>linux/amd64</code> 和 <code>linux/arm64</code> 两个平台。</li><li><code>--name cross-builder</code>：指定构建器的名称。</li><li><code>--driver docker-container</code>：使用 <code>docker-container</code> 驱动，即在容器中运行 BuildKit。</li><li><code>--driver-opt image=192.168.10.10:5000/moby/buildkit:buildx-stable-1</code>：指定使用的 BuildKit 镜像。</li><li><code>--buildkitd-config /root/.docker/buildx/buildkitd.default.toml</code>：指定 BuildKit 的配置文件。</li><li><code>--bootstrap</code>: 直接初始化此构建器</li></ul><h4 id=34-验证构建器状态>3.4 验证构建器状态<a hidden class=anchor aria-hidden=true href=#34-验证构建器状态>#</a></h4><p>使用以下命令验证构建器状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker buildx ls
</span></span></code></pre></div><p>输出结果应该类似于：</p><pre tabindex=0><code>NAME/NODE            DRIVER/ENDPOINT                   STATUS    BUILDKIT   PLATFORMS
cross-builder*       docker-container
 \_ cross-builder0    \_ unix:///var/run/docker.sock   running   v0.13.2    linux/amd64*, linux/arm64*, linux/amd64/v2, linux/amd64/v3, linux/386
default              docker
 \_ default           \_ default                       running   v0.13.1    linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/386
</code></pre><h3 id=4-使用本地-registry-的技巧>4. 使用本地 Registry 的技巧<a hidden class=anchor aria-hidden=true href=#4-使用本地-registry-的技巧>#</a></h3><p>为了高效地使用本地 Registry，我们可以将不同平台的镜像推送到 Registry 中，并使用 Docker Manifest 将它们聚合为一个多平台镜像。</p><p>以 Ubuntu 24.04 为例，假设我们已经在本地拉取了 <code>linux/amd64</code> 和 <code>linux/arm64</code> 两个平台的镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 拉取 linux/amd64 平台的 Ubuntu 24.04 镜像</span>
</span></span><span class=line><span class=cl>docker pull --platform linux/amd64 ubuntu:24.04
</span></span><span class=line><span class=cl><span class=c1># 重命名镜像并推送到本地 Registry</span>
</span></span><span class=line><span class=cl>docker tag ubuntu:24.04 192.168.10.10:5000/ubuntu-amd64:24.04
</span></span><span class=line><span class=cl>docker push 192.168.10.10:5000/ubuntu-amd64:24.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 拉取 linux/arm64 平台的 Ubuntu 24.04 镜像</span>
</span></span><span class=line><span class=cl>docker pull --platform linux/arm64 ubuntu:24.04
</span></span><span class=line><span class=cl><span class=c1># 重命名镜像并推送到本地 Registry</span>
</span></span><span class=line><span class=cl>docker tag ubuntu:24.04 192.168.10.10:5000/ubuntu-arm64:24.04
</span></span><span class=line><span class=cl>docker push 192.168.10.10:5000/ubuntu-arm64:24.04
</span></span></code></pre></div><p>接下来，使用 Docker Manifest 将这两个平台的镜像聚合为一个多平台镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker manifest create --insecure 192.168.10.10:5000/ubuntu:24.04 192.168.10.10:5000/ubuntu-amd64:24.04 192.168.10.10:5000/ubuntu-arm64:24.04
</span></span><span class=line><span class=cl>docker manifest push --insecure 192.168.10.10:5000/ubuntu:24.04
</span></span></code></pre></div><p>现在，我们就可以在构建多平台镜像时，直接从本地 Registry 拉取 <code>192.168.10.10:5000/ubuntu:24.04</code> 镜像，而无需考虑具体的平台。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>在离线环境下构建多平台 Docker 镜像具有一定的挑战性，但通过合理使用 Docker Buildx 和 Docker Registry，我们可以高效地实现这一目标。本文详细介绍了相关的步骤和命令，希望对您在离线环境下的 Docker 镜像构建工作有所帮助。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://docs.docker.com/reference/cli/docker/buildx/>https://docs.docker.com/reference/cli/docker/buildx/</a></li><li><a href=https://github.com/docker/buildx/discussions/1088>https://github.com/docker/buildx/discussions/1088</a></li><li><a href=https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md>https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md</a></li><li><a href=https://community.arm.com/arm-community-blogs/b/tools-software-ides-blog/posts/deploying-multi-architecture-docker-registry>https://community.arm.com/arm-community-blogs/b/tools-software-ides-blog/posts/deploying-multi-architecture-docker-registry</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mioto.me/tags/docker/>Docker</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mioto.me/>一只麻酱</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>